const {
  JSON: { parse: parseJSON },
  Number: { parseInt },
  Object: { assign, fromEntries },
  URL,
} = globalThis;

const { search: __search } = new URL(import.meta.url);

const { constant, hasOwnProperty } = await import(
  `../../util/index.mjs${__search}`
);
const { prompts } = await import(`../../prompts/index.mjs${__search}`);

// const generateMakeGlobSpecifier = (enabled) => (glob) => ({enabled, glob});
// const makeEnabledGlobSpecifier = generateMakeGlobSpecifier(true);
// const makeDisabledGlobSpecifier = generateMakeGlobSpecifier(false);

// Validate //

const generateValidatePort = (randomable) => (input) => {
  if (/^[0-9]+$/u.test(input)) {
    const port = parseInt(input);
    /* c8 ignore start */
    if (!randomable && port === 0) {
      return "Cannot assign a random port.";
    }
    if (port > 65535) {
      return "Port is out-of-range (the maximum port is 65535).";
    }
    /* c8 ignore stop */
  }
  return true;
};

// Parse //

const parsePossibleInteger = (input) =>
  /^[0-9]+$/u.test(input) ? parseInt(input) : input;

// Format //

const questions = [
  // Naming //
  constant({
    type: "text",
    name: "value",
    initial: "",
    message: [
      "What is the name of your app?",
      "Skip to let us pick a meaningful a name",
    ],
    format: (app_name) => (app_name === "" ? {} : { name: app_name }),
  }),
  // Recorder //
  constant({
    type: "select",
    name: "value",
    initial: 0,
    message: ["How appmaps should be generated?"],
    choices: [
      {
        title: "By recording processes",
        value: { recorder: "process" },
        description: [
          "Record node processes from start to finish.",
          "A single appmap will be generated per spawned node process.",
        ].join(" "),
      },
      {
        title: "By recording mocha test cases",
        value: { recorder: "mocha" },
        description: [
          "An appmap will be generated for each mocha test case.",
        ].join(" "),
      },
      {
        title: "By remote HTTP requests",
        value: { recorder: "remote" },
        description: [
          "Appmaps will be generated on demand via HTTP requests.",
          "These requests can be send via the record button in our editors plugins.",
          "VSCode: https://marketplace.visualstudio.com/items?itemName=appland.appmap.",
          "JetBrains: https://plugins.jetbrains.com/plugin/16701-appmap.",
        ].join(" "),
      },
      {
        title: "Manually",
        value: {
          recorder: "manual",
          hooks: { cjs: false, esm: false },
          packages: [{ regexp: "^", flags: "u", enabled: true }],
        },
        description: [
          "Appmaps will be generated by user-defined logics located in the recorded process.",
          "NB: To record functions applications, code should be given to: `appmap.recordScript(code, path)`.",
        ].join(" "),
      },
    ],
  }),
  // Scenario //
  ({ recorder }) =>
    recorder === "manual"
      ? null
      : {
          type: "text",
          name: "value",
          message: [
            "What command should be executed and recorded when running `npx appmap-agent-js`?",
            "The command should be provided as a JSON array of strings.",
            'For instance: ["node", "path/to/main.js"]',
            "Skip to provide the command as positional argument.",
            "For instance: `npx appmap-agent-js -- node path/to/main.js",
          ],
          initial: "",
          format: (input) =>
            input === "" ? {} : { command: parseJSON(input) },
        },
  // Remote Recording //
  ({ recorder }) =>
    recorder !== "remote"
      ? null
      : {
          type: "text",
          name: "value",
          message: [
            "On which primary port should the agent listen for remote recording requests?",
            "Either provide a port number or a path to a unix domain socket.",
            "Provide `0` to use a random available port.",
          ],
          initial: "0",
          validate: generateValidatePort(true),
          format: (input) => ({
            "track-port": parsePossibleInteger(input),
          }),
        },
  ({ recorder }) =>
    recorder !== "remote"
      ? null
      : {
          type: "text",
          name: "value",
          message: [
            "On which secondary port should to agent intercept remote recording requests?",
            "The agent will expect the recorded application to deploy a HTTP server on that port.",
            "Either provide a port number or a path to a unix domain socket.",
            "Skip to disable this functionality.",
          ],
          initial: "",
          validate: generateValidatePort(false),
          format: (input) => ({
            "intercept-track-port": parsePossibleInteger(input),
          }),
        },
  // Storage //
  ({ recorder }) =>
    recorder !== "process" && recorder !== "mocha"
      ? null
      : {
          type: "text",
          name: "value",
          message: [
            "Where should appmap files be written?",
            "Provide a relative path to a directory.",
          ],
          initial: "tmp/appmap",
          format: (directory) => ({ appmap_dir: directory }),
        },
  // Hooks //
  ({ recorder }) => ({
    type: "multiselect",
    name: "value",
    message: ["What are the things that you are interested into recording?"],
    instructions: false,
    choices: [
      {
        title: "Applications of functions located in CommonJS modules",
        value: "cjs",
        disabled: recorder === "manual",
        selected: recorder !== "manual",
      },
      {
        title: "Application of functions located in native modules",
        value: "esm",
        disabled: recorder === "manual",
        selected: recorder !== "manual",
      },
      {
        title: "HTTP/1.1 traffic (via node's builtin http package)",
        value: "http",
        disabled: false,
        selected: true,
      },
      {
        title: "MySQL queries (via mysql package)",
        value: "mysql",
        disabled: false,
        selected: false,
      },
      {
        title: "Postgres queries (via pg package)",
        value: "pg",
        disabled: false,
        selected: false,
      },
      {
        title: "SQLite3 queries (via sqlite3 package)",
        value: "sqlite3",
        disabled: false,
        selected: false,
      },
    ],
    format: (keys) => ({
      hooks: {
        esm: false,
        cjs: false,
        http: false,
        mysql: false,
        pg: false,
        sqlite3: false,
        ...fromEntries(keys.map((key) => [key, true])),
      },
    }),
  }),
  constant({
    type: "select",
    name: "value",
    message: ["How should events be ordered?"],
    initial: 0,
    choices: [
      {
        title: "Chronologically",
        value: { ordering: "chronological" },
        description: "Events will not be re-ordered.",
      },
      {
        title: "Causally",
        value: { ordering: "causal" },
        description: [
          "Events will be re-ordered based on causality links.",
          "For instance, asynchronous callbacks will (often) appear as nested calls rather than top-level calls.",
          "NB: This comes at the price of performance overhead",
        ].join(" "),
      },
    ],
  }),
  // Whitelisting //
  // ({ recorder }) =>
  //   recorder === "manual"
  //     ? null
  //     : {
  //         type: "list",
  //         name: "value",
  //         message: [
  //           "What are the node processes that should be recorded?",
  //           "Useful to prevent child node processes from being recorded.",
  //           "Whitelisting is based on the path of the entry script.",
  //           "Provide a coma-separated list of globs.",
  //         ],
  //         initial: "bin/*, test/*, test/**/*",
  //         separator: ",",
  //         format: (globs) => ({ processes: globs.map(makeGlobSpecifier) }),
  //       },
  // ({ recorder }) =>
  //   recorder === "manual"
  //     ? null
  //     : {
  //         type: "list",
  //         name: "value",
  //         message: [
  //           "What are the files that should be recorded?",
  //           "By default, every files inside the repository are recorded."
  //           "Safe for files within `node_modules` directories which are ignored."
  //           "Provide a coma-separated list of globs.",
  //         ],
  //         initial: "",
  //         separator: ",",
  //         format: (globs) => ({ packages: globs.map(makeEnabledGlobSpecifier) }),
  //       },
  // Pruning //
  ({ recorder }) => ({
    type: "toggle",
    name: "value",
    message: ["Should we include code that did not get executed in appmaps?"],
    initial: recorder !== "mocha",
    active: "yes",
    inactive: "no",
    format: (complete) => ({ pruning: !complete }),
  }),
  // Log //
  constant({
    type: "select",
    name: "value",
    message: ["What level of information should be logged?"],
    initial: 1,
    choices: [
      {
        title: "Debug",
        value: { log: "debug" },
      },
      {
        title: "Info",
        value: { log: "info" },
      },
      {
        title: "Warning",
        value: { log: "warning" },
      },
      {
        title: "Error",
        value: { log: "error" },
      },
      {
        title: "Off",
        value: { log: "off" },
      },
    ],
  }),
];

export const questionConfigAsync = async () => {
  const config = {};
  for (const createPrompt of questions) {
    const prompt = createPrompt(config);
    if (prompt !== null) {
      const { message, ...rest } = prompt;
      const result = await prompts({
        message: `${
          message.length === 1 ? message[0] : message.join("\n  ")
        }\n`,
        ...rest,
      });
      if (hasOwnProperty(result, "value")) {
        assign(config, result.value);
      } else {
        break;
      }
    }
  }
  return config;
};
