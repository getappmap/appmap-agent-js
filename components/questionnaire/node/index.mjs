const { parse: parseJSON } = JSON;
const { parseInt } = Number;
const { assign } = Object;

const { fromEntries } = Object;

export default (dependencies) => {
  const {
    prompts: { prompts },
    util: { constant, hasOwnProperty },
  } = dependencies;

  // const generateMakeGlobSpecifier = (enabled) => (glob) => ({enabled, glob});
  // const makeEnabledGlobSpecifier = generateMakeGlobSpecifier(true);
  // const makeDisabledGlobSpecifier = generateMakeGlobSpecifier(false);

  // Validate //

  const generateValidatePort = (randomable) => (input) => {
    if (/^[0-9]+$/u.test(input)) {
      const port = parseInt(input);
      /* c8 ignore start */
      if (!randomable && port === 0) {
        return "Cannot assign a random port.";
      }
      if (port > 65535) {
        return "Port is out-of-range (the maximum port is 65535).";
      }
      /* c8 ignore stop */
    }
    return true;
  };

  // Parse //

  const parsePossibleInteger = (input) =>
    /^[0-9]+$/u.test(input) ? parseInt(input) : input;

  // Format //

  const questions = [
    // Naming //
    constant({
      type: "text",
      name: "value",
      initial: "",
      message: [
        "What is the name of your app?",
        "Skip to let us pick a meaningful a name",
      ],
      format: (app_name) => (app_name === "" ? {} : { name: app_name }),
    }),
    // Recorder //
    constant({
      type: "select",
      name: "value",
      initial: 0,
      message: ["How appmaps should be generated?"],
      choices: [
        {
          title: "By recording processes",
          value: { recorder: "process" },
          description: [
            "Record node processes from start to finish.",
            "A single appmap will be generated per spawned node process.",
          ].join(" "),
        },
        {
          title: "By recording mocha test cases",
          value: { recorder: "mocha" },
          description: [
            "An appmap will be generated for each mocha test case.",
          ].join(" "),
        },
        {
          title: "By remote HTTP requests",
          value: { recorder: "remote" },
          description: [
            "Appmaps will be generated on demand via HTTP requests.",
            "These requests can be send via the record button in our editors plugins.",
            "VSCode: https://marketplace.visualstudio.com/items?itemName=appland.appmap.",
            "JetBrains: https://plugins.jetbrains.com/plugin/16701-appmap.",
          ].join(" "),
        },
        {
          title: "Manually",
          value: {
            recorder: "manual",
            hooks: { cjs: false, esm: false },
            packages: [{ regexp: "^", flags: "u", enabled: true }],
          },
          description: [
            "Appmaps will be generated by user-defined logics located in the recorded process.",
            "NB: To record functions applications, code should be given to: `appmap.recordScript(code, path)`.",
          ].join(" "),
        },
      ],
    }),
    // Scenario //
    ({ recorder }) =>
      recorder === "manual"
        ? null
        : {
            type: "text",
            name: "value",
            message: [
              "What command should be executed and recorded when running `npx appmap-agent-js`?",
              "The command should be provided as a JSON array of strings.",
              'For instance: ["node", "path/to/main.js"]',
              "Skip to provide the command as positional argument.",
              "For instance: `npx appmap-agent-js -- node path/to/main.js",
            ],
            initial: "",
            format: (input) =>
              input === "" ? {} : { command: parseJSON(input) },
          },
    // Remote Recording //
    ({ recorder }) =>
      recorder !== "remote"
        ? null
        : {
            type: "text",
            name: "value",
            message: [
              "On which primary port should the agent listen for remote recording requests?",
              "Either provide a port number or a path to a unix domain socket.",
              "Provide `0` to use a random available port.",
            ],
            initial: "0",
            validate: generateValidatePort(true),
            format: (input) => ({
              "track-port": parsePossibleInteger(input),
            }),
          },
    ({ recorder }) =>
      recorder !== "remote"
        ? null
        : {
            type: "text",
            name: "value",
            message: [
              "On which secondary port should to agent intercept remote recording requests?",
              "The agent will expect the recorded application to deploy a HTTP server on that port.",
              "Either provide a port number or a path to a unix domain socket.",
              "Skip to disable this functionality.",
            ],
            initial: "",
            validate: generateValidatePort(false),
            format: (input) => ({
              "intercept-track-port": parsePossibleInteger(input),
            }),
          },
    // Storage //
    ({ recorder }) =>
      recorder !== "process" && recorder !== "mocha"
        ? null
        : {
            type: "text",
            name: "value",
            message: [
              "Where should appmap files be written?",
              "Provide a relative path to a directory.",
            ],
            initial: "tmp/appmap",
            format: (directory) => ({ output: { directory } }),
          },
    // Hooks //
    ({ recorder }) => ({
      type: "multiselect",
      name: "value",
      message: ["What are the things that you are interested into recording?"],
      instructions: false,
      choices: [
        {
          title: "Applications of functions located in CommonJS modules",
          value: "cjs",
          disabled: recorder === "manual",
          selected: recorder !== "manual",
        },
        {
          title: "Application of functions located in native modules",
          value: "esm",
          disabled: recorder === "manual",
          selected: recorder !== "manual",
        },
        {
          title: "HTTP/1.1 traffic (via node's builtin http package)",
          value: "http",
          disabled: false,
          selected: true,
        },
        {
          title: "MySQL queries (via mysql package)",
          value: "mysql",
          disabled: false,
          selected: false,
        },
        {
          title: "Postgres queries (via pg package)",
          value: "pg",
          disabled: false,
          selected: false,
        },
        {
          title: "SQLite3 queries (via sqlite3 package)",
          value: "sqlite3",
          disabled: false,
          selected: false,
        },
      ],
      format: (keys) => ({
        hooks: {
          esm: false,
          cjs: false,
          http: false,
          mysql: false,
          pg: false,
          sqlite3: false,
          ...fromEntries(keys.map((key) => [key, true])),
        },
      }),
    }),
    constant({
      type: "select",
      name: "value",
      message: ["How should events be ordered?"],
      initial: 0,
      choices: [
        {
          title: "Chronologically",
          value: { ordering: "chronological" },
          description: "Events will not be re-ordered.",
        },
        {
          title: "Causally",
          value: { ordering: "causal" },
          description: [
            "Events will be re-ordered based on causality links.",
            "For instance, asynchronous callbacks will (often) appear as nested calls rather than top-level calls.",
            "NB: This comes at the price of performance overhead",
          ].join(" "),
        },
      ],
    }),
    // Whitelisting //
    // ({ recorder }) =>
    //   recorder === "manual"
    //     ? null
    //     : {
    //         type: "list",
    //         name: "value",
    //         message: [
    //           "What are the node processes that should be recorded?",
    //           "Useful to prevent child node processes from being recorded.",
    //           "Whitelisting is based on the path of the entry script.",
    //           "Provide a coma-separated list of globs.",
    //         ],
    //         initial: "bin/*, test/*, test/**/*",
    //         separator: ",",
    //         format: (globs) => ({ processes: globs.map(makeGlobSpecifier) }),
    //       },
    // ({ recorder }) =>
    //   recorder === "manual"
    //     ? null
    //     : {
    //         type: "list",
    //         name: "value",
    //         message: [
    //           "What are the files that should be recorded?",
    //           "By default, every files inside the repository are recorded."
    //           "Safe for files within `node_modules` directories which are ignored."
    //           "Provide a coma-separated list of globs.",
    //         ],
    //         initial: "",
    //         separator: ",",
    //         format: (globs) => ({ packages: globs.map(makeEnabledGlobSpecifier) }),
    //       },
    // Pruning //
    ({ recorder }) => ({
      type: "toggle",
      name: "value",
      message: ["Should we include code that did not get executed in appmaps?"],
      initial: recorder !== "mocha",
      active: "yes",
      inactive: "no",
      format: (complete) => ({ pruning: !complete }),
    }),
    // Log //
    constant({
      type: "select",
      name: "value",
      message: ["What level of information should be logged?"],
      initial: 1,
      choices: [
        {
          title: "Debug",
          value: { log: "debug" },
        },
        {
          title: "Info",
          value: { log: "info" },
        },
        {
          title: "Warning",
          value: { log: "warning" },
        },
        {
          title: "Error",
          value: { log: "error" },
        },
        {
          title: "Off",
          value: { log: "off" },
        },
      ],
    }),
  ];

  const questionConfigAsync = async () => {
    const config = {};
    for (const createPrompt of questions) {
      const prompt = createPrompt(config);
      if (prompt !== null) {
        const { message, ...rest } = prompt;
        const result = await prompts({
          message:
            message.length === 1 ? message[0] : message.join("\n  ") + "\n",
          ...rest,
        });
        if (hasOwnProperty(result, "value")) {
          assign(config, result.value);
        } else {
          break;
        }
      }
    }
    return config;
  };

  return { questionConfigAsync };
};
